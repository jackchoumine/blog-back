# RESTful webservice 实战笔记



## 使用统一的接口

HTTP 是一种应用层协议，定义在**资源**在客户端和服务器之间的转移，诸如`GET`、`POST`、`PUT`、`DELETE`等方法，是对资源的操作。HTTP 本身是具有语义的，正确使用HTTP，可使得 web api 更具有自说明性，不必或者只要提供**简要的**的文档说明，api 使用者就能知道如何使用。

### 如何保持交互的可见性

作为应用层协议，HTTP 的设计目标是在客户端和服务器之间保持对库、服务器、代理、缓存和其他工具的可见性。可见性很难理解，我认为定义为设备之间可互操作性更为准确，只要设备知道接口定义，设备之间就可通过HTTP 通信。那么如何确保这种可互操作性呢？要是接口按照**统一的**约定或者规范定义，那么保持这种互操作性可以实现，而基于HTTP语义的约定是最为简单的，RESTful 就是充分利用了HTTP语义的一种接口设计规范。保持可互操作性需要保持两条原则：

1. **使用方法时，和其语义保持一致，并添加标头来描述请求和响应**；
2. 正确使用**状态码**和**状态消息**，以便代理、缓存和客户端可以决定如何操作请求结果。

> 在某些情况下，为了其他特定，可降低或放弃可见性，比如为了提高网络效率、客户端是否方便使用响应、缓存、等幂、安全等。

在实际的接口设计中，方便客户端使用、安全、提高网络效率是降低可互操作性的原因。但是实际上，只要支持HTTP的设备，只要知道接口定义，就能相互操作，本质上的互操作性是给人看的。

### 如何在服务器端实现安全和幂等的方法

一个HTTP方法不会修改资源时，它就是安全的。只读操作使用安全的方法，才能保证请求安全。幂等保证客户端重复发起一个请求，和一次请求的效果一致。幂等性大多和网络或者软件故障相关。方法的幂等，可以保证在遇到软件故障时，可以发送**多次相同的请求**，而不必担心改变资源。

| 方法    | 安全 | 幂等 | 操作                                   | 备注                                                         |
| ------- | ---- | ---- | -------------------------------------- | ------------------------------------------------------------ |
| GET     | Yes  | Yes  | 获取资源，返回 200                     | 不要在不安全不幂等的操作中使用GET，否则可能会不符合预期地改变资源。 |
| HEAD    | Yes  | Yes  |                                        |                                                              |
| OPTIONS | Yes  | Yes  |                                        |                                                              |
| PUT     | No   | Yes  | 新建或者更新一个资源                   |                                                              |
| DELETE  | No   | Yes  | 删除资源，返回 200                     | 要是实现幂等，服务器要维护资源的状态，知道资源已经被删除。否则可能会返回404。因为第二次删除资源就不存在了。实际上返回404更合理。 |
| POST    | No   | No   | 创建多个资源或者对资源进行多种其他操作 |                                                              |

####  何时使用POST

- 新建资源或者修改多个资源；
- 大数据的输入查询；
- 其他方法都不适合，执行不安全或者非幂等的操作；
- 提交密码、信用卡等敏感信息时必须使用POST。
#### 如何使用POST 创建资源
在创建资源后，返回 201，并在Location头中指定新资源的 URI。如果在响应正文中包含了新建资源的完整表述，在 Content-Location 头中包含新资源的URI。可在请求的 Slug 中指定新资源RUI的建议，服务器未必采用。
请求得到响应，未必操作就已经完成，比如银行转账、在服务器上处理图片等比较耗时的操作。这类需要长时间才能完成的操作，返回 202 表示已经接收到请求，客户端在提交GET请求以询问操作状态时，**执行中，返回200**，响应中包含当前状态的表述，**成功。303**，提供 Location，执行新资源，**失败，200，给出失败原因**。
其实这种做法，非常不方便客户端处理，实际设计时，都返回200，并在响应中标识是否成功。
> 303，仅指出请求资源在Location中，并不是资源已经转移到新的URI。

### 如何使用 PUT 创建资源
只有在客户端能决定新资源的URI时才使用PUT创建资源，否则使用POST。比如存储服务器为每个客户端分配根路径，并让客户端把根路径作为文件系统的根目录，在客户端创建资源时，希望控制目录，客户端也应该控制目录。
使用PUT创建资源时，服务器需要先客户端说明RUI是如何组织的，同时希望客户端创建资源时使用最小范围的URI。POST创建资源，服务器具有更多的控制权，更少的工作。

## 识别资源

### 如何从领域名词中识别资源

分析用例，找到可以使用`创建`、`读取`、`更新`、`删除`动作来操作的领域名词，将这些名词识别为资源。

### 如何控制资源粒度
将资源直接映射到领域实体，会导致资源粒度很低，客户端希望更多的资源时，需要发送很多请求，导致网络效率低下和客户端难以处理响应，确定合适的资源粒度就非常关键。
在设计资源时，结合**客户端使用是否方便**、**网络效率**来确定适合的粒度。以下因素也会影响资源粒度：
- 是否可缓存；
- 修改频率；
- 可变性。
设计粒度时，要确保更多的缓存、更低的修改频率，或者吧可变的数据分离出来。
### 如何将资源组织成集合
将相似的资源归为一个集合或者数组，通过GET方法来获取整个集合而不是单独获取，比如设计网站用户的好用列表，电商网站用户购物车里的商品。
### 如何合并资源为符合资源
将多个资源合并成一个资源会降低互操作性，但是有时候不得不组合，在代码上上表现的结果是，一个资源成为另一个资源的字段。
比如有两个资源：
```js
{
	name:"jack", //一个人的资源
	age:24
}
```
图书资源：
```js
{
	bookName:"restful 实战",
	price:46
}
```
想要获取用户最近阅读的书籍，需要发送两次请求，这样网络效率会低。
可以书籍资源合并：
```js
{
	name:"jack",
	age:24,
	books:[]//最近阅读的书籍
}
```
组合资源会导致资源重叠，组合之前，需要考虑以下问题：
- 客户端对组合资源的请求是否很少，很少就不组合；
- 网络开销，客户端和服务器的网络开销，服务器和其他服务器的网络开销，要说后者很大，收到客户端请求，再去其他服务器请求资源来组合，会导致客户端和服务器之间的网络开销也很多大，可以增加缓存或者现在服务器上组合好资源。
## 设计表述

客户端所关心的资源是一个抽象的实体，它是用  URI 来标识的。另一方面，表述是具体而真实的，您在客户端和服务器上针对它编写代码，进行操作。

### 如何使用实体头注解表述

表述不仅仅是以某种格式序列化后的数据，它是一连串字节加上用于描述那些字节的元数据。在  HTTP  中，表述元数据是由使用实体头的名值对（name-value pair）来实现的。这些实体头和应用数据本身一样重要。

#### 您想知道在对服务器的请求或对客户端的响应中应该发送哪些  HTTP 头。
- Content-Type，用于描述表述类型，包含  charset  参数或其他针对该媒体类型而定义的参数。告知接收方如何处理响应。
- Content-Length，用于指定表述正文的字节大小。
- Content-Language，如果您以某种语言对表述进行本地化，用该标头来指定语言。
- Content-MD5，工具 / 软件在处理或存储表述时可能存在错误，需要提供一致性校验，用该标头来包含一个表述正文的  MD5 摘要。请注意，TCP  使用  checksum 在传输层提供一致性校验。
- Content-Encoding，当您使用  gzip,compress 或  deflate 对表述正文进行编码时，使用该标头。
- Last-Modified，用来说明服务器修改表述或资源的最后时间。

HTTP 的设计是这样的，发送方可以用一系列名为实体头的标头来描述表述正文（也称为实体正文或消息正文）。有了这些标头，接收方可以在无须查看正文的情况下决定如何处理正文。它们还可以将解析正文所需要提前了解及猜测的内容减到最小程度。

Content-Length
这个标头最早是在  HTTP 1.0 中被引入的，接收方用它来判断自己是否从连接中读取了正确的字节数。要发送该标头，发送方需要在写正文前计算出表述的大小。HTTP 1.1 支持一种更有效的机制，名为分块转移编码（chuncked transfer encoding）这让 Content-Length 头变得有点多余。对于  POST 和  PUT 请求，就算使用了 ** Transfer-Encoding: chuncked**，也要在客户端应用程序的请求中包含  Content-Length 头。因为有些代理会拒绝没有包含这两个头的  POST 和  PUT 请求。

Content-Language
当表述针对某种语言做了本地化之后，请使用该标头，它的值是两个字母的  RFC 5646 语言标签，还可以在后面带上连字符（-）和任意两个字母的国家代码。
比如
```html
<html lang="en-US"> <!--美式英语-->
<html lang="en-GB"> <!--英式英语-->
<html lang="zh-CN"> <!--中国汉语，因为还有新加坡汉语-->
```
[更多关于网页设置语言的信息](https://www.biaodianfu.com/langtag.html)
[完整的语言标记](http://www.loc.gov/standards/iso639-2/php/code_list.php?__cf_chl_jschl_tk__=c59b6c71bfc56434eddedcf024568f34cc8bb985-1590866144-0-AXSz2y3QWCwkfEYQaD_9OzTeVOijYE22O1jFMxNO5fvz0iWvkccWtBwwxiQbejam6id8sqXQkT4Hfro4NmtLaGOBSrVtMfEkAQ1bWuF7ET-zR-94STr8QvZx7Nebo-55j4nFEI3E2Ee6UhIhHFojT96arV8YeUBxcPmxT793E7egvk72zzyuRucAy2KCVZIMZCNZMEPtTq4i-L1pfes0dzjCO4g-6NpOQUNEFpobpue9cE5ihb9LFYLj3Vx_9bJ2h6l1A3iWEsq9iJYCqBiWN5F_Owv4cMK9u3-oF9MzFuMBerrSXGY2P5S6Hajb_13p7Q)
 Content-MD5
接收方可以使用该标头来验证实体正文的完整性。该标头的值是表述正文的  MD5 摘要，在进行内容编码（gzip,compress  等）之后，转移编码（即  chunked）之前计算摘要值。
因为这个标头不能保证消息没有被篡改，所以不要将它作为一种安全手段。**修改了正文的人同样可以修改标头的值。**
在通过非可靠网络发送或接受大的表述时，这个标头非常有用。表述的发送方包含了  Content-MD5 头之后，接收方可以在解析前先验证消息的完整性。

Content-Encoding
这个标头说明了表述正文所使用的压缩类型，它的值可以是类似  gzip,compress 或  deflate 这样的字符串。
客户端可以用  Accept-Encoding 头（详见第 7 章）来注明自己偏好的  Content-Encoding。然而，并没有一个标准的方式让客户端了解到服务器是否可以处理用给定编码压缩过的表述。除非您事先知道目标服务器支持某个特定的编码方法，否则应该避免在 HTTP 请求中使用这个标头。

Last-Modified
这个标头只用在响应上，它的值是一个时间戳，表示服务器最后修改资源表述的时间。

#### 如何正确解析实体头
当服务器或客户端接收到表述时，在处理请求前正确地解释实体头是很重要的。
Content-Type
当您收到一个不带  Content-Type 的表述时，避免猜测表述的类型。当客户端发送不带该标头的请求时，返回错误码 400（Bad Request）。当您从服务器接收到一个不带该标头的响应时，将其视为不正确的响应。
Content-Length
在没有确定接收到的表述不带  Transfer-Encoding: chunked  前，不要检查 Content-Length 头是否存在。
Content-Encoding
让您的网络库代码来解压那些压缩过的表述。
Content-Language
如果存在该标头，读取并存储它的值，记录下所使用的语言。

####  如何避免字符编码不匹配
表述的发送方和接收方之间的字符编码不匹配通常会造成数据损坏和解析错误。由于字符编码不匹配造成的错误很难发现。
在发送表述时，如果媒体类型允许使用  charset 参数，则包含一个带字符编码值的 charset 参数，该参数值将被用于将字符转为字节。
当您接收到一个表述，其中带有支持  charset 参数的媒体类型，在从表述正文的字节中构造字符流时，使用指定的编码。如果忽略了发送方提供的  charset 值，使用其他的值，那么应用程序很可能会把字符给解释错。
诸如 ** application/xml**、**text/html**、**application/atom+xml** 和 **text/csv** 这样的文本和  XML 媒体类型允许您指定字符编码，通过  Content-Type 头中的  charset 参数，使用该字符编码将字符转换为实体正文中的字节。比如
```bash
Content-Type:application/xml;charset=UTF-8
```
诸如  application/xml,text/html,application/atom+xml 和 text/csv 这样的文本和  XML 媒体类型允许您指定字符编码，通过  Content-Type 头中的  charset 参数，使用该字符编码将字符转换为实体正文中的字节。
还要避免针对  XML  格式的表述使用  text/xml  媒体类型。text/xml  的默认字符是 us-ascii，而  application/xml 使用  UTF-8。

常用的标准或知名的媒体类型

常用的分段媒体类型

#### 如何理解服务器返回的错误？

| 状态码 | 状态文本                 | 说明                                                         |
| ------ | ------------------------ | ------------------------------------------------------------ |
| 400    | Bad Request              | 正文不对，检查正文                                           |
| 401    | Unauthorized             | 带有  Authorization 头的请求进行重试，其中包含身份信息       |
| 403    | Forbidden                | 禁止客户端用这个请求方法来访问资源                           |
| 404    | Not Found                | 资源已经不存在了                                             |
| 413    | Request Entity Too Large | 正文里寻找关于有效长度的提示                                 |
| 415    | Unsupported Media Type   | 请求支持的媒体类型不对                                       |
| 500    | Internal Server Error    | 服务代码出错                                                 |
| 503    | Service Unavailable      | 如果响应中有  Retry-After  头，在到达该时间前不要重试。这可能是整个服务器的错误，因此在客户端中要实现适当的补偿逻辑，在一段时间内避免向服务器发送请求。 |
| 502    | Bad Gateway              | 通常不是客户端能够修复的，而是需要由途径的 Web 服务器或者代理服务器对其进行修复。 |

但是这些状态码往往不够用，在设计接口时，通常都返回 200，在表述中告知是否错误。

## 设计URI

URI  是跨越  Web  的资源描述符，一个  URI 由以下内容组成 —— 协议（例如  http 和 https）、主机（例如  www.example.org）、端口号，后面紧跟一段或多段路径（例如 /user/1234），还有查询字符串。

**URI***（统一资源标识符）*是一个指向资源的字符串。最通常用在 [URL](https://developer.mozilla.org/en-US/docs/Glossary/URL) 上来指定 Web 上资源文件的具体位置。相比之下，[URN](https://developer.mozilla.org/en-US/docs/Glossary/URN) 是在给定的命名空间用名字指向具体的资源

#### 资源设计  URI 的最佳实践

- 在  URI 的路径部分使用斜杠分隔符（/）来表示资源之间的层次关系。
- 使用连字符（-）来改善长路径中名称的可读性。
- 在  URI 的查询部分使用 “与” 符号（&）来分隔参数。
- 在  URI 中避免出现文件扩展名（例如.php,.aspx 和.jsp）。
- 保持URI分格的一致性，尤其是多人协作时。

##  web 链接 

链接提供了一种方式，可以从一个资源导航到另一个资源。但是本章的内容，实际开发想要按照 RESTful  定义接口，会非常繁琐，在返回实体中包含链接，也无实际用处。

##  Atom 和 AtomPub

没看到有实际作用，不记录。

## 内容协商

内容协商（Content Negotiation），有时也简写为  conneg，该过程用于当存在多个可用的资源表述形式时，为客户端选择一个最好的出来。内容协商常用于标明媒介类型的偏好，但它也可以用于标明本地化语言、字符编码以及压缩方面的偏好。

#### 客户端如何标明内容偏好

实现客户端时，一件重要的事情就是该客户端要能够向服务器标明自己的偏好和能力，包括它所能够处理的表述格式，所偏好的语言，能够识别的字符编码，以及它是否支持压缩。对于响应中的表述，即便事先知道它的格式、字符编码、语言以及压缩类型，清楚明确地标明客户端的偏好以及能力将更有助于客户端适应各种变化。

在请求头中添加一个  Accept ，其值是一个偏好媒体类型的列表，以逗号分隔。根据客户端对各种媒体类型的偏好程度，可以再设定一个参数  q，默认值为 1.0，可精确到三位小数。 “*;q=0.0”，来向服务器标明自己无法处理那些没有列在  Accept 头里的媒体类型。

请求中没有  Accept 头，那就使用默认格式来返回被请求资源的表述。请求中含有  Accept 头，那就解析它，并按照  q 参数降序排序媒体类型的值。然后从此列表中选择一个服务器所支持的媒体类型。在响应中要包含一个  Vary 头。

如果客户端仅能处理属于某一种字符集的字符，那就增加一个 **Accept-Charset** 头，其值就是所偏好的字符集。否则，就不要添加这个头。

请求中没有  Accept-Charset 头，那就以  UTF-8 对返回的表述进行编码。
如果请求中含有  Accept-Charset 头，那就解析它，依照  q 参数对那些字符集进行排序，然后选择服务器所支持的字符编码。
如果服务器端不支持任何所请求的字符集，并且  Accept-Charset  头中不包含 “*;q=0.0”，那么就使用  UTF-8 编码返回的表述。

有这些情况中，如果媒体类型是文本的，并且允许使用  charset  参数，就在 Content-Type 头中包含  charset 参数，以标明服务器所用的字符编码。同样，在响应中也要包含一个  Vary 头。

 Accept-Language 头来指明表述所偏好的语言。

请求中不含有  Accept-Language 头，那就在返回的表述中对所有给人阅读的文字使用默认的语言。
如果请求中含有  Accept-Language 头，那就解析它，依照  q 参数对语言进行排序，选择列表里的第一个服务器所支持的语言。在响应中包含一个  Vary 头，详见 7.6 节。
如果列表里的语言服务器端一个也不支持，并且  Accept-Language  头也不包含 “*;q=0.0”，那就在响应里使用默认的语言。

客户端能够解压那些采用诸如  gzip,compress 或者  deflate 编码的压缩表述，就添加一个  **Accept-Encoding** 头并列出所支持的编码格式，否则就略过该标头。

服务器支持压缩响应内容，那就从  Accept-Encoding 头中选择一种压缩技术。在响应中同样也要包含一个  Vary 头，详见 7.6 节。如果服务器所支持的压缩编码没有一个位于标头中，那就忽略它。对于  q 参数的处理同其他  Acceopt-* 的情况。
如果请求中不包含  Accept-Encoding 头，就不要对表述进行压缩。

```js
Accept:application/atom+xml;q=1.0,application/xml;q=0.6,*/*;q=0.0
Accept-Language:fr;q=1.0,en;q=0.5
Accept-Charset:UTF-8
Accept-Encoding:gzip
```

####   何时以及如何发送 Vary 头

当服务器使用内容协商来选择表述时，根据  Accept-* 头的不同，同一个  URI 可以产生不同的表述。Vary 头告诉客户端服务器在选择表述时使用了哪些请求头。

每当针对一个资源有多种形式的表述可用时，就要包含一个  Vary 头。该标头的值是一些请求头的列表，以逗号分隔，服务器在选择表述时参考了这些请求头。如果服务器还使用了除这些请求头之外的信息，例如客户端的  IP 地址、当前时间、用户个性化设置等，那就将  Vary 头的值设置为 *。

服务器可以用  Vary 头来通知客户端服务器驱动内容协商的结果。Vary 头的值是一组**请求头**，而不是响应头。

针对英语表述的请求：

```js
GET /status HTTP/1.1
Host:www.example.com
Accept-Language:en;q=1.0,*/*;q=0.0
```

响应

```js
HTTP/1.1 200 OK
Content-Language:de
Vary:Accept-Language
```

针对法语表述的请求

```js
GET /status HTTP/1.1
Host:www.exampe.com
Accepet-Language:fr;q=1.0,*/*;q=1.0
```

响应：

```js
HTTP/1.1 200 OK
Content-Language:fr
Vary:Accept-Language
```

缓存把这个标头作为缓存键的一部分，来维持表述的不同副本。客户端可以使用这个信息来获知服务器用于内容协商的标准。

#### 如何处理内容协商失败

知道当服务器无法提供客户端所偏好的表述时，是该提供一个默认的表述，还是该返回一个错误。

服务器无法提供满足客户端偏好的表述，并且客户端明确包含了一个 “*/*;q=0.0”，那就返回状态码 **406（Not Acceptable）**，并在表述主体中包含表述的列表。

请求：只接受json 格式的响应。

```js
GET /status HTTP/1.1
Host:www.example.com
Accept:application/json,*/*;q=0.0
```

服务器无法满足客户端的格式要求，返回 406，在表述中以JSON格式给出理由

```js
406 Not Acceptable
Content-Type:application/json

{
    message:'This server does not support json.'
}
```

请注意，服务器给出的错误信息本身使用了  JSON  格式。这是合理的，服务器完全可以使用常见的格式来实现错误信息。

## 查询

查询信息是  HTTP GET 方法的一种常见应用。查询通常涉及三个组成部分，即过滤（filtering）、排序（sorting）和投影（projection）。过滤是基于一些过滤条件选择实体的一个子集的过程。排序会影响服务器是如何排列响应中结果的。投影是选择实体中的哪些字段将被包含到结果中的过程。例如，发送到电影服务器的查询请求可能会涉及按类型过滤电影，然后根据上映日期倒序排序，最后在返回客户端的响应中只选择标题、年份以及每部电影的简单介绍。

只要关注过  URI 和表述，查询设计还是相对比较简单的。客户端负责运行查询，服务器的职责包括设计  URI 来支持过滤、排序和投影，设计表述，设置合适的缓存头。

####  如何针对查询设计 URI

使用查询参数来设计查询是一种常用惯例，根据自己的用例，可能需要支持以下一种或全部情况的查询参数：
● 从可用资源中选择数据
● 指定排序条件
● 罗列要包含在响应中的资源的字段

#### 如何设计大量输入的查询

使用 POST 实现查询，Content-Type application/x-www-form-urlencoded 的格式，服务器实现设计成等幂和安全的。使用POST进行查询，会丧失缓存功能。

## 缓存

缓存是构建于  HTTP 统一接口之上的最有用的功能之一。可以利用缓存减少终端用户感知到的延时，增加可靠性，减少带宽使用和成本，降低服务器负载。缓存无处不在，可以在服务器网络里、内容分发网络（content delivery network，简称  CDN）或是客户端网络里。

通常所说的缓存可以是类似  memcached（http://memcached.org/）这样的对象缓存，或者 Squid（http://www.squid-cache.org/）和 Traffic Server（http://incubator.apache.org/projects/trafficserver.html）这样的  HTTP  缓存。 HTTP  缓存不需要客户端或服务器调用任何特殊的编程  API  来管理缓存中的数据，对象缓存需要调用特定的缓存API实现。

####  如何设置过期缓存头

当缓存可以在不访问源服务器时做出尽可能多的响应时，它是最高效的。设计过期缓存（Expiration Caching）就是为了降低源服务器收到的请求数量，同时减少应用程序使用的带宽。过期缓存基于  Cache-Control  和  Expires 这两个头，它们指导客户端和缓存在一段指定的时间内保存从服务器返回的表述副本。**在这个时间窗口以内，甚至超出该时间窗口，缓存可以对后续请求做出响应，无须访问服务器。**

在提供表述时，包含一个  Cache-Control  头，其中带有一个与新鲜寿命（freshness lifetime）相同的  max-age 值（单位为秒）。

Cache-Control 是一个  HTTP 1.1 头，为了支持遗留的  HTTP 1.0 缓存，还要包含一个带过期日期时间的  Expires 头。过期时间是服务器生成表述的时间加上新鲜寿命。还要包含一个带有日期时间的  Date 头，即服务器返回响应的时间。这个标头能帮助客户端计算新鲜寿命，即为  Expires 和 Date 两值之差。

不让缓存提供副本，则加上一个带  no-cache 值的  Cache-Control 头。这里还要加上  Pragma: no-cache 头来支持遗留的  HTTP 1.0 缓存。

 Cache-Control 的值

| 值                    | 说明                                                         |      |
| --------------------- | ------------------------------------------------------------ | ---- |
| public                | 这是默认指令。当请求是经过身份验证的，但您仍希望共享缓存提供缓存响应时，也可以使用该指令。 |      |
| private               | 当响应专属于某个客户端或用户时，使用该指令。出现这个指令，任意客户端缓存（例如，浏览器缓存或转发代理）都可以缓存表述，但诸如服务器缓存或网络缓存之类的共享缓存则不能进行缓存。在基于客户端或用户身份验证来提供表述的时候添加该指令。 |      |
| no-cache 和  no-store | 通过这些指令可以避免缓存存储或提供已经缓存的响应。           |      |
| max-age               | 该指令的值即为新鲜寿命，单位为秒。                           |      |
| s-maxage              | 这个指令与  max-age  类似，但只对共享缓存有意义。在源服务器同时设置了 max-age 和 s-maxage 的时候，缓存会使用 s-maxage 头。实际上，单独设置 max-age 指令就足够了。 |      |
| must-revalidate       | 缓存在提供陈旧的表述前先检查源服务器。                       |      |
| proxy-revalidate      | 与  must-revalidate 指令类似，但它只应用于共享缓存。         |      |

